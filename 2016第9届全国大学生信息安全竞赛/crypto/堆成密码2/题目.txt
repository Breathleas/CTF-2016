 现有一个对称密码算法，能够使用任意长的密钥对任意长的明文（plaintext）进行加密，并能对密文（cipher）进行解密。算法的实现源代码如test.c所示。 在没有对应的密钥的情况下，请参照test.c的sample3，破解出下列密文对应明文，以获得flag。 
Please recover the plaintext from the cipher:

char  *sample3_cipher = {

0x54,0x31,0xB5,0x1B,0xCF,0x8C,0x6E,0x7E,

0x87,0x6A,0xA3,0x24,0xEE,0x14,0x52,0x1C,

0x24,0x7E,0x0C,0xF8,0x47,0xEA,0xB1,0xC8,

0x3E,0x07,0x57,0x7E,0x27,0xA7,0x71,0xA3,

0x14,0xE4,0x70,0xD0,0x7F,0xA8,0x65,0x06,

0x45,0x23,0x57,0x14,

};

注意：直接进行全局密钥空间穷举的解题方法，将被判定无效，得分在最终结果中将被扣除。

提示1：明文符合flag的格式要求，即为：flag{…}

提示2：3轮加密

提示3：密钥可不一定是可见字符哦